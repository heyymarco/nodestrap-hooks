// react (builds html using javascript):
import {
    default as React,
}                           from 'react'         // base technology of our cssfn components

// cssfn:
import type {
    SingleOrArray,
    Factory,

    Dictionary,
    ValueOf,
    DictionaryOf,
}                           from './types'       // cssfn's types
import type {
    PropEx,
    Cust,
}                           from './css-types'   // ts defs support for jss
import {
    // general types:
    Style,
    RuleEntry,
    RuleList,


    // styles:
    createCssfnStyle,


    // compositions:
    mainComposition,


    // layouts:
    layout,


    // rules:
    variants,
    states,
    rule,


    // functions:
    propsFn,


    // utilities:
    solidBackg,


    // prop's utilities:
    decl,
    ref,


    // utils:
    pascalCase,
    camelCase,
}                           from './cssfn'       // cssfn core
import {
    createCssConfig,


    // utilities:
    usesGeneralProps,
    usesSuffixedProps,
    overwriteProps,
}                           from './css-config'  // Stores & retrieves configuration using *css custom properties* (css variables)
import
    colors,
    * as color              from './colors'      // configurable colors & theming defs
import
    borders,
    * as border             from './borders'     // configurable borders & border radiuses defs
import spacers              from './spacers'     // configurable spaces defs
import typos                from './typos/index' // configurable typography (texting) defs



// styles:
//#region props
//#region foreground
/**
 * themed foreground color.
 */
export const _foregTh            = 'foregTh'

/**
 * conditional foreground color.
 */
export const _foregIfIf          = 'foregIfIf'

/**
 * conditional unthemed foreground color.
 */
export const _foregIf            = 'foregIf'

/**
 * functional foreground color.
 */
export const _foregFn            = 'foregFn'
//#endregion foreground

//#region background
/**
 * themed background.
 */
export const _backgTh            = 'backgTh'

/**
 * conditional background.
 */
export const _backgIfIf          = 'backgIfIf'

/**
 * conditional unthemed background.
 */
export const _backgIf            = 'backgIf'

/**
 * functional backgrounds.
 */
export const _backgFn            = 'backgFn'

/**
 * toggles background gradient.
 */
export const _backgGradTg        = 'backgGradTg'
//#endregion background

//#region border
/**
 * themed border color.
 */
export const _borderTh           = 'borderTh'

/**
 * conditional border color.
 */
export const _borderIfIf         = 'borderIfIf'

/**
 * conditional unthemed border color.
 */
export const _borderIf           = 'borderIf'

/**
 * functional border color.
 */
export const _borderFn           = 'borderFn'
//#endregion border



//#region outlined - foreground
/**
 * themed foreground color - at outlined variant.
 */
export const _outlinedForegTh    = 'outlinedForegTh'

/**
 * conditional foreground color - at outlined variant.
 */
export const _outlinedForegIfIf  = 'outlinedForegIfIf'

/**
 * conditional unthemed foreground color - at outlined variant.
 */
export const _outlinedForegIf    = 'outlinedForegIf'

/**
 * functional foreground color - at outlined variant.
 */
export const _outlinedForegFn    = 'outlinedForegFn'

/**
 * toggles *on* foreground color - at outlined variant.
 */
export const _outlinedForegTg    = 'outlinedForegTg'
//#endregion outlined - foreground

//#region outlined - background
/**
 * functional backgrounds - at outlined variant.
 */
export const _outlinedBackgFn    = 'outlinedBackgFn'

/**
 * toggles *on* backgrounds - at outlined variant.
 */
export const _outlinedBackgTg    = 'outlinedBackgTg'
//#endregion outlined - background



//#region mild - foreground
/**
 * themed foreground color - at mild variant.
 */
export const _mildForegTh        = 'mildForegTh'

/**
 * conditional foreground color - at mild variant.
 */
export const _mildForegIfIf      = 'mildForegIfIf'

/**
 * conditional unthemed foreground color - at mild variant.
 */
export const _mildForegIf        = 'mildForegIf'

/**
 * functional foreground color - at mild variant.
 */
export const _mildForegFn        = 'mildForegFn'

/**
 * toggles *on* foreground color - at mild variant.
 */
export const _mildForegTg        = 'mildForegTg'
//#endregion mild - foreground

//#region mild - background
/**
 * themed background - at mild variant.
 */
export const _mildBackgTh        = 'mildBackgTh'

/**
 * conditional background - at mild variant.
 */
export const _mildBackgIfIf      = 'mildBackgIfIf'

/**
 * conditional unthemed background - at mild variant.
 */
export const _mildBackgIf        = 'mildBackgIf'

/**
 * functional backgrounds - at mild variant.
 */
export const _mildBackgFn        = 'mildBackgFn'

/**
 * toggles *on* backgrounds - at mild variant.
 */
export const _mildBackgTg        = 'mildBackgTg'
//#endregion mild - background



//#region boxShadow-focus
/**
 * Supports for Control
 */



/**
 * focused themed box-shadow color.
 */
export const _boxShadowFocusTh   = 'boxShadowFocusTh'

/**
 * focused conditional box-shadow color.
 */
export const _boxShadowFocusIfIf = 'boxShadowFocusIfIf'

/**
 * focused conditional unthemed box-shadow color.
 */
export const _boxShadowFocusIf   = 'boxShadowFocusIf'

/**
 * focused functional box-shadow color.
 */
export const _boxShadowFocusFn   = 'boxShadowFocusFn'
//#endregion boxShadow-focus



//#region finals
/**
 * final foreground color.
 */
export const _foreg              = 'foreg'

/**
 * final background color.
 */
export const _backgCol           = 'backgCol'
/**
 * final background color as solid background.
 */
export const _backgSol           = 'backgSol'
/**
 * final backgrounds.
 */
export const _backg              = 'backg'

/**
 * final border color.
 */
export const _borderCol          = 'borderCol'

/**
 * final box-shadow.
 */
export const _boxShadow          = 'boxShadow'

/**
 * final filter.
 */
export const _filter             = 'filter'

/**
 * final animation.
 */
export const _anim               = 'anim'
//#endregion finals



//#region animations
/**
 * none background.
 */
export const _backgNone             = 'backgNone'

/**
 * none box shadow.
 */
export const _boxShadowNone         = 'boxShadowNone'

/**
 * none filter.
 */
export const _filterNone            = 'filterNone'

/**
 * none transform.
 */
export const _transfNone            = 'transfNone'

/**
 * none animation.
 */
export const _animNone              = 'animNone'
//#endregion animations
//#endregion props

//#region themeVariants
/**
 * Creates color definitions *for each* `themeOptions()`.
 * @returns A `RuleList` represents the color definitions *for each* `themeOptions()`.
 */
export const usesThemeVariants = (options = themeOptions(), factory = themeOf): RuleList => options.map((theme) => rule(
    `.th${pascalCase(theme)}`,
    factory(theme)
));
/**
 * Gets the all available theme options.
 * @returns A `string[]` represents the all available theme options.
 */
export const themeOptions = (): string[] => Object.keys(color.themes);
/**
 * Creates a color definition for the specified `theme`.
 * @param theme The current theme name written in camel case.
 * @returns A `JssStyle` represents the color definition for the current `theme`.
 */
export const themeOf = (theme: string): Style => {
    return {
        [decl(_foregTh)]          : (colors as DictionaryOf<typeof colors>)[`${theme}Text`],   // light on dark backg | dark on light backg
        [decl(_backgTh)]          : (colors as DictionaryOf<typeof colors>)[theme],
        [decl(_borderTh)]         : (colors as DictionaryOf<typeof colors>)[`${theme}Bold`],   // 20% background + 80% page's foreground
        [decl(_outlinedForegTh)]  : ref(_backgTh),
        [decl(_mildForegTh)]      : ref(_borderTh),
        [decl(_mildBackgTh)]      : (colors as DictionaryOf<typeof colors>)[`${theme}Mild`],   // // 20% background + 80% page's background
        [decl(_boxShadowFocusTh)] : (colors as DictionaryOf<typeof colors>)[`${theme}Thin`],
    };
}
//#endregion themeVariants

/**
 * Creates sizing definitions *for each* `sizeOptions()`.
 * @returns A `RuleList` represents the sizing definitions *for each* `sizeOptions()`.
 */
export const usesSizes = (options = sizeOptions(), factory = sizeOf): RuleList => options.map((size) => rule(
    `.sz${pascalCase(size)}`,
    factory(size)
));
/**
 * Gets the all available size options.
 * @returns A `string[]` represents the all available size options.
 */
export const sizeOptions = (): string[] => ['sm', 'lg'];
/**
 * Creates a sizing definition for the specified `size`.
 * @param size The current size name written in camel case.
 * @returns A `JssStyle` represents the sizing definition for the current `size`.
 */
export const sizeOf = (size: string): Style => ({
    // overwrites propName = propName{Size}:
    ...overwriteProps(cssDecls, usesSuffixedProps(cssProps, size)),
});


export const usesGradient = (off = noGradient, on = isGradient): RuleList => [
    rule(':not(.gradient)' , off(/*inherit =*/true)),
    rule(     '.gradient'  , on()                  ),
];
/**
 * Creates a no gradient definition when the gradient variant is disabled.
 * @returns A `JssStyle` represents the no gradient definition.
 */
export const noGradient = (inherit = false): SingleOrArray<Style> => ({
    // *toggle off* the background gradient prop:
    [decl(_backgGradTg)]     : inherit ? 'unset' : 'initial',
});
/**
 * Creates a gradient definition when the gradient variant is enabled.
 * @returns A `JssStyle` represents the gradient definition.
 */
export const isGradient = (): SingleOrArray<Style> => ({
    // *toggle on* the background gradient prop:
    [decl(_backgGradTg)]     : cssProps.backgGrad,
});


export const usesOutlined = (off = noOutlined, on = isOutlined): RuleList => [
    // grandpa ??? .outlined and parent not .outlined and current not .outlined:
    rule(                     ':not(.outlined)&:not(.outlined)' , off(/*inherit =*/false)), // can't inherit, because outlined() uses dedicated color theme

    // grandpa iss .outlined or  parent is  .outlined or  current is  .outlined:
    // double `.outlined.outlined` to combat with `:not(.outlined)&:not(.outlined)`
    rule(['.outlined.outlined &',  '.outlined&',  '&.outlined'] , on()                   ),
];
/**
 * Creates a no outlined definition when the outlined variant is disabled.
 * @returns A `JssStyle` represents the no outlined definition.
 */
export const noOutlined = (inherit = false): SingleOrArray<Style> => ({
    // *toggle off* the outlined props:
    [decl(_outlinedForegTg)] : inherit ? 'unset' : 'initial',
    [decl(_outlinedBackgTg)] : inherit ? 'unset' : 'initial',
});
/**
 * Creates an outlined definition when the outlined variant is enabled.
 * @returns A `JssStyle` represents the outlined definition.
 */
export const isOutlined = (): SingleOrArray<Style> => [usesPropsFn(),{
    // *toggle on* the outlined props:
    [decl(_outlinedForegTg)] : ref(_outlinedForegFn),
    [decl(_outlinedBackgTg)] : ref(_outlinedBackgFn),
}];


export const usesMild = (off = noMild, on = isMild): RuleList => [
    // grandpa's .mild does not affect the .mild
    // parent not .mild and current not .mild:
    rule(':not(.mild)&:not(.mild)' , off(/*inherit =*/false)), // can't inherit, because mild() uses dedicated color theme

    // parent is  .mild or  current is  .mild:
    rule([    '.mild&',  '&.mild'] , on()                   ),
];
/**
 * Creates a no mild definition when the mild variant is disabled.
 * @returns A `JssStyle` represents the no mild definition.
 */
export const noMild = (inherit = false): SingleOrArray<Style> => ({
    // *toggle off* the mild props:
    [decl(_mildForegTg)] : inherit ? 'unset' : 'initial',
    [decl(_mildBackgTg)] : inherit ? 'unset' : 'initial',
});
/**
 * Creates a mild definition when the mild variant is enabled.
 * @returns A `JssStyle` represents the mild definition.
 */
export const isMild = (): SingleOrArray<Style> => [usesPropsFn(),{
    // *toggle on* the mild props:
    [decl(_mildForegTg)] : ref(_mildForegFn),
    [decl(_mildBackgTg)] : ref(_mildBackgFn),
}];


export const usesPropsFn = () => propsFn({
    //#region nones
    // define a *none* background:
    [decl(_backgNone)]     : solidBackg('transparent'),

    // define a *none* box shadow:
    [decl(_boxShadowNone)] : [[0, 0, 'transparent']],

    // define a *none* filter:
    [decl(_filterNone)]    : 'brightness(100%)',

    // define a *none* transform:
    [decl(_transfNone)]    : 'translate(0)',

    // define a *none* animation:
    [decl(_animNone)]      : 'none',
    //#endregion nones



    // define a *foreground* color func:
    [decl(_foregFn)] : ref(
        _foregIfIf, // first  priority
        _foregTh,   // second priority
        _foregIf,   // third  priority
    ),

    // define a *backgrounds* func:
    [decl(_backgFn)] : ref(
        _backgIfIf, // first  priority
        _backgTh,   // second priority
        _backgIf,   // third  priority
    ),

    // define a *border* color func:
    [decl(_borderFn)] : ref(
        _borderIfIf, // first  priority
        _borderTh,   // second priority
        _borderIf,   // third  priority
    ),

    
    
    // define a *foreground* color func - at *outlined* state:
    [decl(_outlinedForegFn)] : ref(
        _outlinedForegIfIf, // first  priority
        _outlinedForegTh,   // second priority
        _outlinedForegIf,   // third  priority
    ),

    // define a *backgrounds* func - at *outlined* state:
    [decl(_outlinedBackgFn)] : 'transparent',


    
    // define a mild *foreground* color func:
    [decl(_mildForegFn)] : ref(
        _mildForegIfIf, // first  priority
        _mildForegTh,   // second priority
        _mildForegIf,   // third  priority
    ),

    // define a mild *backgrounds* func:
    [decl(_mildBackgFn)] : ref(
        _mildBackgIfIf, // first  priority
        _mildBackgTh,   // second priority
        _mildBackgIf,   // third  priority
    ),

    

    // define a *focused box-shadow color* func:
    [decl(_boxShadowFocusFn)]: [[
        cssProps.boxShadowFocus,      // box-shadow pos, width, spread, etc

        // box-shadow color:
        ref(
            _boxShadowFocusIfIf, // first  priority
            _boxShadowFocusTh,   // second priority
            _boxShadowFocusIf    // third  priority
        )
    ]],



    //#region finals
    // define a final *foreground* color func:
    [decl(_foreg)]     : ref(
        _outlinedForegTg, // toggle outlined
        _mildForegTg,     // toggle mild
        _foregFn,
    ),

    // define a final *background* color func:
    [decl(_backgCol)]  : ref(
        _outlinedBackgTg, // toggle outlined
        _mildBackgTg,     // toggle mild
        _backgFn,
    ),
    [decl(_backgSol)]  : solidBackg(ref(_backgCol)),
    // define a final *backgrounds* func:
    [decl(_backg)] : [
        // top layer:
        ref(
            _backgGradTg,
            _backgNone,
        ),

        // middle layer:
        ref(_backgSol),

        // bottom layer:
        cssProps.backg,
    ],

    // define a final *border* color func:
    [decl(_borderCol)] : ref(
        _outlinedForegTg, // toggle outlined
        _borderFn
    ),

    // define a final *box-shadow* func:
    [decl(_boxShadow)] : boxShadowFn(), // single array (including from the returning function) => makes the JSS treat as comma separated values

    // define a final *filter* func:
    [decl(_filter)]    : [filterFn()],  // double array (including from the returning function) => makes the JSS treat as space separated values

    // define a final *animation* func:
    [decl(_anim)]      : animFn(),      // single array (including from the returning function) => makes the JSS treat as comma separated values
    //#endregion finals
});
/**
 * Creates a composite boxShadow definition in which the boxShadows *depends on* the variants and/or the states.
 * @returns A `Cust.Ref[]` represents the composite boxShadow definition.
 */
export const boxShadowFn = (): Cust.Ref[] => { return [
    cssProps.boxShadow,
]}
/**
 * Creates a composite filter definition in which the filters *depends on* the variants and/or the states.
 * @returns A `Cust.Ref[]` represents the composite filter definition.
 */
export const filterFn = (): Cust.Ref[] => { return [
    cssProps.filter,
]}
/**
 * Creates a composite animation definition in which the animations *depends on* the variants and/or the states.
 * @returns A `Cust.Ref[]` represents the composite animation definition.
 */
export const animFn = (): Cust.Ref[] => { return [
    cssProps.anim,
]}

export const basicComponentStyle = createCssfnStyle(() => [
    mainComposition([
        layout({
            // customize:
            ...usesGeneralProps(cssProps), // apply *general* cssProps
        
        
        
            // foregrounds:
            foreg       : ref(_foreg),
    
    
    
            // backgrounds:
            backg       : ref(_backg),
            
            
            
            // borders:
            borderColor : ref(_borderCol),
    
    
    
            // states & animations:
            boxShadow   : ref(_boxShadow),
            filter      : ref(_filter),
            anim        : ref(_anim),
        }),
        variants([
            usesThemeVariants(),
            usesSizes(),

            usesGradient(),
            usesOutlined(),
            usesMild(),
        ]),
        states([

        ]),
        usesPropsFn(),
    ]),
]);
export class BasicComponentStyles extends ElementStyles {

    // states:
    public /*override*/ states(inherit: boolean): RuleList { return [



        [ null, {
            // reset filters/anims/toggles to initial/inherit state:
            ...this.resetDefaultState(inherit),
        }],
    ]}

    public /*virtual*/ resetDefaultState(inherit = false): PropList {
        return this.iif(!inherit,
            this.themeDefault() // reset theme to default
        );
    }

    public /*virtual*/ themeDefault(theme: string|null = null): PropList {
        if (theme) return this.themeIf(theme);
        
        
        
        return {
            [this.decl(this._foregIf)]          : cssProps.foreg,
            [this.decl(this._backgIf)]          : 'transparent',
            [this.decl(this._borderIf)]         : cssProps.borderColor,
            [this.decl(this._outlinedForegIf)]  : this.ref(this._foregIf),
            [this.decl(this._mildForegIf)]      : this.ref(this._foregIf),
            [this.decl(this._mildBackgIf)]      : this.ref(this._backgIf),
            [this.decl(this._boxShadowFocusIf)] : colors.secondaryThin,
        };
    }
    /**
     * Creates a conditional color definition for the specified `theme`.
     * @param theme The theme name written in camel case.
     * @returns A `PropList` represents the conditional color definition for the specified `theme`.
     */
    public /*final*/ themeIf(theme: string): PropList { return {
        [this.decl(this._foregIf)]          : (colors as DictionaryOf<typeof colors>)[`${theme}Text`],   // light on dark backg | dark on light backg
        [this.decl(this._backgIf)]          : (colors as DictionaryOf<typeof colors>)[theme],
        [this.decl(this._borderIf)]         : (colors as DictionaryOf<typeof colors>)[`${theme}Bold`],   // 20% background + 80% page's foreground
        [this.decl(this._outlinedForegIf)]  : this.ref(this._backgIf),
        [this.decl(this._mildForegIf)]      : this.ref(this._borderIf),
        [this.decl(this._mildBackgIf)]      : (colors as DictionaryOf<typeof colors>)[`${theme}Mild`],   // // 20% background + 80% page's background
        [this.decl(this._boxShadowFocusIf)] : (colors as DictionaryOf<typeof colors>)[`${theme}Thin`],
    }}
    /**
     * Creates an important conditional color definition for the specified `theme`.
     * @param theme The theme name written in camel case.
     * @returns A `PropList` represents the important conditional color definition for the specified `theme`.
     */
    public /*final*/ themeIfIf(theme: string): PropList { return {
        [this.decl(this._foregIfIf)]          : (colors as DictionaryOf<typeof colors>)[`${theme}Text`],   // light on dark backg | dark on light backg
        [this.decl(this._backgIfIf)]          : (colors as DictionaryOf<typeof colors>)[theme],
        [this.decl(this._borderIfIf)]         : (colors as DictionaryOf<typeof colors>)[`${theme}Bold`],   // 20% background + 80% page's foreground
        [this.decl(this._outlinedForegIfIf)]  : this.ref(this._backgIfIf),
        [this.decl(this._mildForegIfIf)]      : this.ref(this._borderIfIf),
        [this.decl(this._mildBackgIfIf)]      : (colors as DictionaryOf<typeof colors>)[`${theme}Mild`],   // // 20% background + 80% page's background
        [this.decl(this._boxShadowFocusIfIf)] : (colors as DictionaryOf<typeof colors>)[`${theme}Thin`],
    }}
}



// configs:
export const [cssProps, cssDecls, cssVals, cssConfig] = createCssConfig(() => {
    const keyframesNone : PropEx.Keyframes = { };

    
    
    return {
        //#region typos
        fontSize          : typos.fontSizeNm,
        fontSizeSm        : [['calc((', typos.fontSizeSm, '+', typos.fontSizeNm, ')/2)']],
        fontSizeLg        : typos.fontSizeMd,
        fontFamily        : 'inherit',
        fontWeight        : 'inherit',
        fontStyle         : 'inherit',
        textDecoration    : 'inherit',
        lineHeight        : 'inherit',
        //#endregion typos

        
        
        //#region foreg, backg, borders
        foreg             : 'currentColor',
        
        backg             : 'transparent',
        backgGrad         : [['linear-gradient(180deg, rgba(255,255,255, 0.2), rgba(0,0,0, 0.2))', 'border-box']],
        
        border            : borders.default,
        borderColor       : borders.color,
        borderRadius      : border.radiuses.md,
        borderRadiusSm    : border.radiuses.sm,
        borderRadiusLg    : border.radiuses.lg,
        //#endregion foreg, backg, borders

        
        
        //#region spacings
        paddingInline     : [['calc((', spacers.sm, '+', spacers.md, ')/2)']],
        paddingBlock      : [['calc((', spacers.xs, '+', spacers.sm, ')/2)']],
        paddingInlineSm   : spacers.sm,
        paddingBlockSm    : spacers.xs,
        paddingInlineLg   : spacers.md,
        paddingBlockLg    : spacers.sm,
        //#endregion spacings

        
        
        // appearances:
        opacity           : 1,


        
        //#region animations
        transition        : [
            ['color'      , '300ms', 'ease-out'],
            ['background' , '300ms', 'ease-out'],
            ['border'     , '300ms', 'ease-out'],
            ['inline-size', '300ms', 'ease-out'],
            ['block-size' , '300ms', 'ease-out'],
            ['font-size'  , '300ms', 'ease-out'],
            ['opacity'    , '300ms', 'ease-out'],
        ],

        // TODO: remove none...
        boxShadowNone     : [[0, 0, 'transparent']],
        boxShadow         : [[0, 0, 'transparent']],
        boxShadowFocus    : [[0, 0, 0, '0.25rem' ]], // supports for Control children's theming

        // TODO: remove none...
        filterNone        : 'brightness(100%)',
        filter            : 'brightness(100%)',

        '@keyframes none' : keyframesNone,
        // TODO: remove none...
        animNone          : [[keyframesNone]],
        anim              : [[keyframesNone]],
        //#endregion animations
    };
}, { prefix: 'bsc' });



// hooks:

export interface VariantTheme {
    theme?: string
}
export function useVariantTheme(props: VariantTheme, themeDefault?: () => (string|undefined)) {
    const theme = props.theme ?? themeDefault?.();
    return {
        class: theme ? `th${pascalCase(theme)}` : null,
    };
}

export interface VariantSize {
    size?: 'sm' | 'lg' | string
}
export function useVariantSize(props: VariantSize) {
    return {
        class: props.size ? `sz${pascalCase(props.size)}` : null,
    };
}

export interface VariantGradient {
    gradient?: boolean
}
export function useVariantGradient(props: VariantGradient) {
    return {
        class: props.gradient ? 'gradient' : null,
    };
}

export interface VariantOutlined {
    outlined?: boolean
}
export function useVariantOutlined(props: VariantOutlined) {
    return {
        class: props.outlined ? 'outlined' : null,
    };
}

export interface VariantMild {
    mild?: boolean
}
export function useVariantMild(props: VariantMild) {
    return {
        class: props.mild ? 'mild' : null,
    };
}

export type OrientationStyle = 'block'|'inline'
export interface VariantOrientation {
    orientation?: OrientationStyle
}
export function useVariantOrientation(props: VariantOrientation) {
    return {
        class: props.orientation ? props.orientation : null,
    };
}



// react components:

export interface BasicComponentProps<TElement extends HTMLElement = HTMLElement>
    extends
        ElementProps<TElement>,
        
        VariantTheme,
        VariantSize,
        VariantGradient,
        VariantOutlined,
        VariantMild
{
}
export default function BasicComponent<TElement extends HTMLElement = HTMLElement>(props: BasicComponentProps<TElement>) {
    // styles:
    const styles       = basicComponentStyles.useStyles();

    
    
    // variants:
    const variTheme    = useVariantTheme(props);
    const variSize     = useVariantSize(props);
    const variGradient = useVariantGradient(props);
    const variOutlined = useVariantOutlined(props);
    const variMild     = useVariantMild(props);



    // jsx:
    return (
        <Element<TElement>
            // other props:
            {...props}


            // classes:
            mainClass={props.mainClass ?? styles.main}
            variantClasses={[...(props.variantClasses ?? []),
                variTheme.class,
                variSize.class,
                variGradient.class,
                variOutlined.class,
                variMild.class,
            ]}
        />
    );
}
export { BasicComponent }
